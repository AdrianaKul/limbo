#!/usr/bin/env python
# encoding: utf-8

import subprocess
import os

all_combinations_init_code = """#include <boost/fusion/container/vector.hpp>
#include <boost/fusion/include/vector.hpp>

#include "limbo/limbo.hpp"

using namespace limbo;

struct Params {

    struct kf_exp {
        BO_PARAM(double, sigma, 1);
    };

    struct kf_maternthreehalfs {
        BO_PARAM(double, sigma, 1);
        BO_PARAM(double, l, 0.2);
    };

    struct kf_maternfivehalfs {
        BO_PARAM(double, sigma, 1);
        BO_PARAM(double, l, 0.2);
    };

    struct meanconstant {
        BO_PARAM_VECTOR(double, constant, 0, 0);
    };

    struct gp_auto : defaults::gp_auto {
    };

    struct gp_auto_mean : defaults::gp_auto_mean {
    };

    struct ucb : public defaults::ucb {
    };

    struct gp_ucb : public defaults::gp_ucb {
    };

    struct exhaustive_search {
        BO_PARAM(int, nb_pts, 20);
    };

    struct cmaes : public defaults::cmaes {
    };

    struct init {
        BO_PARAM(int, nb_samples, 5);
        BO_PARAM(int, nb_bins, 5);
    };

    struct maxiterations {
        BO_PARAM(int, n_iterations, 20);
    };

    struct maxpredictedvalue {
        BO_PARAM(double, ratio, 2);
    };

    struct boptimizer {
        BO_PARAM(double, noise, 0.001);
        BO_PARAM(int, dump_period, 1);
    };
};

struct MeanEval {
    MeanEval(size_t dim_out = 1) {}

    template <typename GP>
    Eigen::VectorXd operator()(const Eigen::VectorXd& x, const GP&) const
    {
        Eigen::VectorXd res(2);
        res(0) = 2.5 * x(0);
        res(1) = -4.5 * x(1);
        return res;
    }
};

struct Average {
    typedef double result_type;
    double operator()(const Eigen::VectorXd& x) const
    {
        return (x(0) + x(1)) / 2;
    }
};

struct StateEval {
    static constexpr size_t dim_in = 2;
    static constexpr size_t dim_out = 2;

    Eigen::VectorXd operator()(const Eigen::VectorXd& x) const
    {
        Eigen::VectorXd res(2);
        res(0) = 3 * x(0) + 5;
        res(1) = -5 * x(1) + 2;
        return res;
    }
};

int main()
{
"""


def create_all_combinations_test(bld):
    kernels = ['Exp', 'MaternThreeHalfs', 'MaternFiveHalfs', 'SquaredExpARD']
    kernel_incompatibility = {}
    kernel_incompatibility['Exp'] = ['GPAuto', 'GPAutoMean']
    kernel_incompatibility['MaternThreeHalfs'] = ['GPAuto', 'GPAutoMean']
    kernel_incompatibility['MaternFiveHalfs'] = ['GPAuto', 'GPAutoMean']

    means = ['NullFunction', 'MeanConstant', 'MeanData', 'MeanFunctionARD']
    mean_additional_params = {}
    mean_additional_params['MeanFunctionARD'] = ['MeanEval']
    mean_incompatibiliy = {}
    mean_incompatibiliy['NullFunction'] = ['GPAutoMean']
    mean_incompatibiliy['MeanConstant'] = ['GPAutoMean']
    mean_incompatibiliy['MeanData'] = ['GPAutoMean']

    models = ['GP', 'GPAuto', 'GPAutoMean']
    acquisitions = ['UCB', 'GP_UCB']
    inner_optis = ['Random', 'ExhaustiveSearch', 'Cmaes']
    inits = ['NoInit', 'RandomSampling', 'RandomSamplingGrid', 'GridSampling']
    stats = ['Acquisitions']
    stops = ['MaxIterations', 'MaxPredictedValue']

    final_code = all_combinations_init_code + '    typedef boost::fusion::vector<' + ', '.join(['stat::' + stat + '<Params>' for stat in stats]) + '> stats_t;\n'
    final_code = final_code + '    typedef boost::fusion::vector<' + ', '.join(['stopping_criterion::' + stop + '<Params>' for stop in stops]) + '> stops_t;\n'

    src_path = bld.path.abspath() + '/combinations'
    if not os.path.exists(src_path):
        os.makedirs(src_path)

    bld.add_post_fun(lambda ctx: subprocess.call('rm -rf ' + src_path, shell=True))

    i = 0
    for kernel in kernels:
        for mean in means:
            for model in models:
                if (kernel in kernel_incompatibility and model in kernel_incompatibility[kernel]) or (mean in mean_incompatibiliy and model in mean_incompatibiliy[mean]):
                    continue
                for acqui in acquisitions:
                    for inner_opt in inner_optis:
                        for init in inits:
                            code = ''
                            code = code + '    typedef kernel_functions::' + kernel + '<Params> kernel_' + str(i) + '_t;\n'
                            code = code + '    typedef mean_functions::' + mean + '<Params' + ('' if (not mean in mean_additional_params) else ',' + ', '.join(mean_additional_params[mean])) + '>' + ' mean_' + str(i) + '_t;\n'
                            code = code + '    typedef model::' + model + '<Params, kernel_' + str(i) + '_t, mean_' + str(i) + '_t> model_' + str(i) + '_t;\n'
                            code = code + '    typedef acquisition_functions::' + acqui + '<Params, model_' + str(i) + '_t> acqui_' + str(i) + '_t;\n'
                            code = code + '    typedef inner_optimization::' + inner_opt + '<Params> inner_opt_' + str(i) + '_t;\n'
                            code = code + '    typedef init_functions::' + init + '<Params> init_' + str(i) + '_t;\n'
                            code = code + '    typedef init_functions::' + init + '<Params> init_' + str(i) + '_t;\n'
                            code = code + '    BOptimizer<Params, model_fun<model_' + str(i) + '_t>, acq_fun<acqui_' + str(i) + '_t>, inneropt_fun<inner_opt_' + str(i) + '_t>, init_fun<init_' + str(i) + '_t>, stat_fun<stats_t>, stop_fun<stops_t>> opt_' + str(i) + ';\n'
                            code = code + '    opt_' + str(i) + '.optimize(StateEval());\n'
                            code = code + '    opt_' + str(i) + '.best_observation();\n'
                            code = code + '    opt_' + str(i) + '.best_sample();\n'
                            code = code + '    opt_' + str(i) + '.optimize(StateEval(), Average(), true);\n'
                            code = code + '    opt_' + str(i) + '.best_observation(Average());\n'
                            code = code + '    opt_' + str(i) + '.best_sample(Average());\n\n'
                            code = final_code + code + '}'
                            with open(bld.path.abspath() + '/combinations/combinations_' + str(i) + '.cpp', 'w') as f:
                                f.write(code)
                            bld.program(features='cxx',
                                        source='/combinations/combinations_' + str(i) + '.cpp',
                                        includes='. .. ../../',
                                        target='/combinations/combinations_' + str(i),
                                        uselib='BOOST EIGEN TBB',
                                        use='limbo')


def build(bld):
    bld.program(features='cxx',
                source='bo_functions.cpp',
                includes='. .. ../../',
                target='bo_functions',
                uselib='BOOST EIGEN TBB',
                use='limbo')
    bld.program(features='cxx test',
                source='test_gp.cpp',
                includes='. .. ../../',
                target='test_gp',
                uselib='BOOST EIGEN TBB',
                use='limbo')
    bld.program(features='cxx test',
                source='test_gp_auto.cpp',
                includes='. .. ../../',
                target='test_gp_auto',
                uselib='BOOST EIGEN TBB',
                use='limbo')
    bld.program(features='cxx test',
                source='test_init_functions.cpp',
                includes='. .. ../../',
                target='test_init_functions',
                uselib='BOOST EIGEN TBB',
                use='limbo')
    bld.program(features='cxx test',
                source='test_inner_opti.cpp',
                includes='. .. ../../',
                target='test_inner_opti',
                uselib='BOOST EIGEN TBB',
                use='limbo')
    bld.program(features='cxx test',
                source='test_macros.cpp',
                includes='. .. ../../',
                target='test_macros',
                uselib='BOOST EIGEN TBB',
                use='limbo')


def build_extensive_tests(ctx):
    create_all_combinations_test(ctx)
